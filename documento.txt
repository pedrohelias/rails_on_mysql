1o passo: rails new "projeto" --database=mysql
2o passo:  gem install mysql2 no projeto(duvida no comando, checar em database.yml )
3o passo: bundle install para rodar as gems no gemfile 
4o passo: rails generate scaffold customer name:string email:string birthday:date obs:text (vai criar views, controllers, migrate, entre outros) -> Para criar a classe customer 
5o passo: rake db:create (para criar as base de dados do projeto, geralmente nomeDoProjeto_development e nomeDoProjeto_test)
6o_passo: rake db:migrate (migrar os dados realizados no 4 passo e criar a tabela de referencia dentro da base de dados). 
7o_passo: É possível observar a tabela criada acessnado o mysql no terminal. 

======================================================================================================


MODELS
Na pasta app, após o scaffold a pasta Models foi prenchida. Um arquivo chamado customer.rb "vazio" com apenas uma única especificação de herança, herdando a classe ActiveRecord::Base. O Active Record é um dos frameworks que constituem o Rails e que toma conta da persistência do banco de dados. Ele que vai fazer a comunicação com o banco de dados e correlacionar com a classe, é um ORM. Sendo assim, ele vai procurar pela tabela correspondente(apenas pelo fato de herdar). O Costumer tem uma tabela gerada na base de dados Customers no plural. Seguindo a convenção nome do model no singular e noma da tabela no plural 

Rails Console ou Rails c -> Vai abrir o console do rails, em um ambiente que vai carregar todas as classes disponiveis no projeto rails. Semelhante ao IRB. Se eu fizesse um a = Customer.first, a variavel a seria composta pelo primeiro elemento da tabela Customers no banco de dados. E isso tudo é possível por conta do ActiveRecord, de fazer a relaçaõ entre classe e banco de dados.


CONTROLERS 

Por convenção o Rails cria um arquivo com o nome da classe no plural + underscore + controller 
No controller, se coloca as ações no sistema, os métodos no padrão:

def action
    #code 
end 

em customers_controller ele cria todos os métodos que solicitamos scaffold. Essa classe herda diretamente de ApplicationController. Existe uma convenção no Rails que pra toda Action eu preciso  ter uma view. Este arquivo é repleto de ações, como a index. A maioria possui. 

Lembrando que variaveis de instancias são iniciadas por @, e dessa forma poderemos utilizar em outra ações. Ou seja, quando definimos uma @variavel, podemos utilizar ela entre o controller e a view. Consigo utilizar uma variavel criada dessa forma na controoler dentro da view. 

=====================================================================================

ROTAS 

o arquivo config/routes.rb possui as rotas do projeto, que serão encontradas a partir da url 

Vamos criar uma rota na mão, mas pra isso precisamos de um controller tambem. Então, para tal: 
rails g controller welcome => Vai gerar(o g é de generate) um controller chamado welcome nos controllers
Dentro de view ele também automaticamente criou uma pasta para definirmos a view desse controller novo 

Agora é só escrever o codigo que se deseja dentro da controller criada welcome_controller.rb 
Com o código produzido, é hora de criar a view. Como o generator apenas criou a pasta, precisaremos criar o arquivo. Então, seu nome será index.html.erb pois o nome da action criada na classe welcome_controller é index, html pois é uma página virtual web, e erb para definir a mistura de html com ruby. 

Para unir a rota da view criada relativa a action index, devemos definir a rota na config/routes.rb 
Uma rapida explicação sobre verbo http. Nos primórdios, foi criado o verbo http Get (vai pegar o que se digitou na pagina e busca no servidor) e http post (vai gravar alguma coisa na web, envio de dados pelo servidor). Para definir uma rota no ruby, primeiramente define-se o verbo (nesse caso get), depois o nome da rota(no caso "inicio"), e por fim o apontamento dessa rota, no caso para a controller welcome que criamos, e para o action "index". 
EScrevendo na sintaxe, temos: 

get "inicio" => "welcome#index"

Um bom teste a ser feito é na classe welcome_controller, a action index, definirmos uma variavel la. No caso, criamos  @teste = "Estou aprendendo rails"

Ja no arquivo da view, para mostrar essa variavel, utilizaremos a estrtuura <%= VARIAVEL %>
No caso, fica assim: <h3><%=@index%></h3>

Para encontrar no browse, é só procurar por "inicio"

Sobre os HELPERS

ActionView::Helpers     link_to (serve para redirecionar paginas )

Então, para isso faremos: 

<%= link_to "Cadastro de Clientes", "/customers"%>

Sendo link_to uma sintaxe normal, o primeiro nome refere-se ao nome do texto, e o segundo nome refere-se ao link que deseja-se acessar. Dessa forma descrita acima e composta pela tag <%=%>
Apesar de nao ser a forma mais correta de se acessar 

Caso acessemos rails/info/routas no url, vamos encontrar todas as rotas disponiveis no projeto. ACessando essa pagina, vimos que a rota para costumer é descrita simplesmente como "customers_path". Ao substituirmos no codigo, vimos que funciona igualmente 

======================================================================================================

REST/RESTFUL
Um conjunto de princípios de arquitetura que definem formas de comunicaçãa via internet. O Rest reproduzir coisas diferntes para que sejam lidas de mesmo jeito. A questão da semântica. 

Há a proposta de POST, GET, PUT e DELETE. Muito relativa ao CRUD. Relancioanndo ao CRUD, teríamos então:

POST = Create 
GET = Read
PUT = Update 
DELETE = Delete 

"resoucers:costurmers" que está escrito no arquivo de rotas vai possibilitar o acesso as 4 funcionaildades do REST. Caso fosse excluído ou apenas comentado, haveria a possibilidade apenas de GET e PUT 

É interessante que no próprio aquivo de de controllers, relacionado a classe Costumers, há a sinalizaçaõ comentada de qual requisição vai indicar a action citada. 

================================================================================================

:Symbols x Strings 

A diferneça principal é a forma como se armazena na memoria. Stirngs ocumpam diferentes espaços, mesmo em caso de objeto(object_id) com nome de string igual. O que difere diretamente de Symbols, que apesar de poder ser selecionado diversas vezes, retonra o mesmo estado, caso ja tenha sido utilizado. 

Pesquisando, criando e persistindo no Banco de Dados. 
Rails C ou rails console para abrir o console do Ruby.

Lembrando que o rails console carrega todas as clsses do projeto, e para pesquisar no rails console, podemos utilizar apenas Ruby, pensando no que diz respeito a banco de dados. Um exemplo:

Queremos listar todas instancias criadas em Customer que representa o modelo que herda diretamente do ActiveDirecotr. Se fizermos: x = Customer.all o console vai retornar todas adiçções realizadas na tabela de customers, vai exibir todos os elementos. 

PAra pesquisar no console, podemos utilizar y = Customer.where(id: 1) OU y = Customer.where(:id => 1) , bastante semelhante a query no sql 

Oara adicionar basta escrever a = Customer.create(name: "Pedro", birthday: Date.today.....)

Da para isntanciar os objetos e depois adicionar as variaveis nele. w = Customer.new 
w.nome = "joao" por exemplo...

O porém é que precisa escrever w.sabe por fim para adicionar todas esses dados a tabela, para garantir a inserção dos mesmos na tabela do banco de dados.

======================================================================================================

Filtros:

before_action X before_filter => São um mesmo elemento, o detalhe é que before_action é o utilizado hoje. Explicitamente, filtros são métodos que seriam rodados antes ou depois de uma ação do controller. Ele vai ordenar o que deve ser feito antes de cada açaõ. Existem algumas actions que estão explciitadas nesse ponto de definição do filtro. 

IMPORTANTE: O Caminho de dados é o seguinte: A partir de uma rota que vai ser acessada, o sistema co-relaciona diretamente com a action associada. E após isso, o sistema encontra a view associada a essa action e a renderiza na página. É possível chamar diferentes partes de views em outras. Por exemplo, numa página x chamar a view do Forms que está em outra view. 

Partials: 

_sua_partial.html.erb  é exxatamente o caso do forms citado acima 

======================================================================================================

Mais sobre Helpers 

Todos elementos presentes em _customer.html.erb são helpers também. "form_for" é um helper que auxilia na construçaõ de formulários. Se passarmos uma variável em branco relacionada a classe criada como argumento do form_for, só por isso, elec criará o formulário. É uma box, então tudo relacionado ao argumento descrito será relacionado com esse argumento descrito.helper. Como no arquivo, temos |f|. Então, teremos f.text_field, f.label. E assim por diante. Neste ponto há a associação do f, que é relativo ao customer. 
Há uma diferença em alguns helpers, relacioandos a associação com a classe. Por exemplo, se não utilizarmos o f.text_field, utilizaremos text_field.tag, fazendo com que se associe a um elemento comum. Pode gerar problemas posteriores. 

PARAMS 

Algumas rotas necessitam de um elemento associado a essa rota para ser encontrada ou determiando. Um exemplo, para exibir um cadastro de customers especifico, a rota é linkada ao customer_path, que é construida a partir de /customer/id . Esse id vai puxar do banco de dados diretamnete o elemento armazenado. Então, params é o que está chegando na requisiçaõ.

=====================================================================================================

Internacionalization

i18n - traduzir a página de forma simples. PAra ativar é simples: config/application.rb
Primeira config: Tirar o comentário de config.i18n.default_locale = "pt-BR".

Dentro de config/locales temos o arquivo en, que represennta o ingles. Devemos criar um outro aquivo então pt-br.yml 
Preenchemos o arquivo com: 
"pt-BR": 
  hello: "Olá Mundo!"

Como utilizar: 
    translate #traduzir textos
    localize #localizar data/hora - fomatação de data e horario 

    Para tal, o i18n já determina algumas classes para realizazr essa operações 
    I18n.t #traduzir
    I18n.l #localize

    Em alguns casos, da pra utlizar apenas t e l 

    em index.html.erb adicionaremos: 

    <h3>
  <%= t('hello')%>
</h3>

Com isso ele trará na tela o Ola mundo em portugues, pois foi definido acima que o padrão está em portugues

Ja para localizar, é necessário criar um arquivo chamado pt-br_rails.yml 
E em seguida preenche-lo com todo texto contigo em: https://github.com/svenfuchs/rails-i18n/blob/master/rails/locale/pt-BR.yml